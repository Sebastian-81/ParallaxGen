#include "ParallaxGen/ParallaxGen.hpp"

#include <spdlog/spdlog.h>
#include <boost/iostreams/device/array.hpp>
#include <boost/iostreams/stream.hpp>
#include <boost/algorithm/string.hpp>
#include <vector>
#include <fstream>
#include <DirectXTex.h>
#include <cmath>

#include "ParallaxGenUtil/ParallaxGenUtil.hpp"

using namespace std;
using namespace ParallaxGenUtil;
using namespace nifly;

ParallaxGen::ParallaxGen(
	const filesystem::path output_dir,
	ParallaxGenDirectory* pgd,
	ParallaxGenD3D* pgd3d,
	const bool optimize_meshes,
	const bool ignore_parallax,
	const bool ignore_complex_material,
	const bool ignore_truepbr
)
{
    // constructor

	// set output directory
	this->output_dir = output_dir;
    this->pgd = pgd;
	this->pgd3d = pgd3d;

	// set optimize meshes flag
	nif_save_options.optimize = optimize_meshes;

	// set ignore flags
	this->ignore_parallax = ignore_parallax;
	this->ignore_complex_material = ignore_complex_material;
	this->ignore_truepbr = ignore_truepbr;
}

void ParallaxGen::upgradeShaders() const
{
	// Get height maps (vanilla _p.dds files)
	auto heightMaps = pgd->getHeightMaps();

	// Define task parameters
	ParallaxGenTask task_tracker("Shader Upgrades", heightMaps.size());

	for (filesystem::path height_map : heightMaps) {
		task_tracker.completeJob(convertHeightMapToComplexMaterial(height_map));
	}
}

void ParallaxGen::patchMeshes() const
{
	auto meshes = pgd->getMeshes();

	// Create task tracker
	ParallaxGenTask task_tracker("Mesh Patcher", meshes.size());

	for (filesystem::path mesh : meshes) {
		task_tracker.completeJob(processNIF(mesh));
	}
}

ParallaxGenTask::PGResult ParallaxGen::convertHeightMapToComplexMaterial(const filesystem::path& height_map) const
{
	spdlog::trace(L"Upgrading height map: {}", height_map.wstring());

	auto result = ParallaxGenTask::PGResult::SUCCESS;

	// Replace "_p" with "_m" in the stem
	filesystem::path env_mask = replaceLastOf(height_map, L"_p.dds", L"_m.dds");
	filesystem::path complex_map = env_mask;

	if (pgd->isComplexMaterialMap(env_mask)) {
		// load order already has a complex material, skip this one
		return result;
	}

	if (!pgd->isFile(env_mask)) {
		// no env map
		env_mask = filesystem::path();
	}

	// upgrade to complex material
	DirectX::ScratchImage new_ComplexMap = pgd3d->upgradeToComplexMaterial(height_map, env_mask);

	// save to file
	if (new_ComplexMap.GetImageCount() > 0) {
		filesystem::path output_path = output_dir / complex_map;
		filesystem::create_directories(output_path.parent_path());

		HRESULT hr = DirectX::SaveToDDSFile(new_ComplexMap.GetImages(), new_ComplexMap.GetImageCount(), new_ComplexMap.GetMetadata(), DirectX::DDS_FLAGS_NONE, output_path.c_str());
		if (FAILED(hr)) {
			spdlog::error(L"Unable to save complex material {}: {}", output_path.wstring(), convertToWstring(ParallaxGenD3D::getHRESULTErrorMessage(hr)));
			result = ParallaxGenTask::PGResult::FAILURE;
			return result;
		}

		// add newly created file to complexMaterialMaps for later processing
		pgd->addComplexMaterialMap(complex_map);

		spdlog::debug(L"Generated complex material map: {}", complex_map.wstring());
	} else {
		result = ParallaxGenTask::PGResult::FAILURE;
	}

	return result;
}

void ParallaxGen::zipMeshes() const {
	// zip meshes
	spdlog::info("Zipping meshes...");
	zipDirectory(output_dir, output_dir / "ParallaxGen_Output.zip");
}

void ParallaxGen::deleteMeshes() const {
	// delete meshes
	spdlog::info("Cleaning up meshes generated by ParallaxGen...");
	// Iterate through the folder
	for (const auto& entry : filesystem::directory_iterator(output_dir)) {
		if (filesystem::is_directory(entry.path())) {
			// Remove the directory and all its contents
			try {
				filesystem::remove_all(entry.path());
				spdlog::trace(L"Deleted directory {}", entry.path().wstring());
			}
			catch (const exception& e) {
				spdlog::error(L"Error deleting directory {}: {}", entry.path().wstring(), convertToWstring(e.what()));
			}
		}

		// remove state file
		if (entry.path().filename().wstring() == L"PARALLAXGEN_DONTDELETE") {
			try {
				filesystem::remove(entry.path());
			}
			catch (const exception& e) {
				spdlog::error(L"Error deleting state file {}: {}", entry.path().wstring(), convertToWstring(e.what()));
			}
		}
	}
}

void ParallaxGen::deleteOutputDir() const {
	// delete output directory
	if (filesystem::exists(output_dir) && filesystem::is_directory(output_dir)) {
		spdlog::info("Deleting existing ParallaxGen output...");

		try {
			for (const auto& entry : filesystem::directory_iterator(output_dir)) {
                filesystem::remove_all(entry.path());
            }
		}
		catch (const exception& e) {
			spdlog::critical(L"Error deleting output directory {}: {}", output_dir.wstring(), convertToWstring(e.what()));
			exitWithUserInput(1);
		}
	}
}

void ParallaxGen::initOutputDir() const {
	// create state file
	ofstream state_file(output_dir / parallax_state_file);
	state_file.close();
}

// shorten some enum names
typedef BSLightingShaderPropertyShaderType BSLSP;
typedef SkyrimShaderPropertyFlags1 SSPF1;
typedef SkyrimShaderPropertyFlags2 SSPF2;
ParallaxGenTask::PGResult ParallaxGen::processNIF(const filesystem::path& nif_file) const
{
	auto result = ParallaxGenTask::PGResult::SUCCESS;

	// Determine output path for patched NIF
	const filesystem::path output_file = output_dir / nif_file;
	if (filesystem::exists(output_file)) {
		spdlog::error(L"Unable to process NIF file, file already exists: {}", nif_file.wstring());
		result = ParallaxGenTask::PGResult::FAILURE;
		return result;
	}

	// Get NIF Bytes
	vector<std::byte> nif_file_data = pgd->getFile(nif_file);
	if (nif_file_data.empty()) {
		spdlog::error(L"Unable to read NIF file: {}", nif_file.wstring());
		result = ParallaxGenTask::PGResult::FAILURE;
		return result;
	}

	// Convert Byte Vector to Stream
	boost::iostreams::array_source nif_array_source(reinterpret_cast<const char*>(nif_file_data.data()), nif_file_data.size());
	boost::iostreams::stream<boost::iostreams::array_source> nif_stream(nif_array_source);

	// NIF file object
	NifFile nif;

	try {
		// try block for loading nif
		// TODO if NIF is a loose file nifly should load it directly
		nif.Load(nif_stream);
	}
	catch (const exception& e) {
		spdlog::error(L"Error reading NIF file: {}, {}", nif_file.wstring(), convertToWstring(e.what()));
		result = ParallaxGenTask::PGResult::FAILURE;
		return result;
	}

	if (!nif.IsValid()) {
		spdlog::error(L"Invalid NIF file (ignoring): {}", nif_file.wstring());
		result = ParallaxGenTask::PGResult::FAILURE;
		return result;
	}

	// Stores whether the NIF has been modified throughout the patching process
	bool nif_modified = false;

	//
	// GLOBAL CHECKS IN NIF
	//

	// Determine if NIF has attached havok animations
	bool has_attached_havok = false;
	vector<NiObject*> block_tree;
	nif.GetTree(block_tree);

	for (NiObject* block : block_tree) {
		if (block->GetBlockName() == "BSBehaviorGraphExtraData") {
			has_attached_havok = true;
		}
	}

	// Patch each shape in NIF
	size_t num_shapes = 0;
	bool one_shape_success = false;
	for (NiShape* shape : nif.GetShapes()) {
		num_shapes++;
		// Get shape's block ID in NIF (used for logging)
		const auto shape_block_id = nif.GetBlockID(shape);

		ParallaxGenTask::updatePGResult(result, processShape(nif_file, nif, shape_block_id, shape, nif_modified, has_attached_havok), ParallaxGenTask::PGResult::SUCCESS_WITH_WARNINGS);
		if (result == ParallaxGenTask::PGResult::SUCCESS) {
			one_shape_success = true;
		}
	}

	if (!one_shape_success && num_shapes > 0) {
		// No shapes were successfully processed
		result = ParallaxGenTask::PGResult::FAILURE;
		return result;
	}

	// Save patched NIF if it was modified
	if (nif_modified) {
		spdlog::debug(L"NIF Patched: {}", nif_file.wstring());

		// create directories if required
		filesystem::create_directories(output_file.parent_path());

		if (nif.Save(output_file, nif_save_options)) {
			spdlog::error(L"Unable to save NIF file: {}", nif_file.wstring());
			result = ParallaxGenTask::PGResult::FAILURE;
			return result;
		}
	}

	return result;
}

ParallaxGenTask::PGResult ParallaxGen::processShape(
	const filesystem::path& nif_file,
	NifFile& nif,
	const uint32_t shape_block_id,
	NiShape* shape,
	bool& nif_modified,
	const bool has_attached_havok
) const
{
	auto result = ParallaxGenTask::PGResult::SUCCESS;

	// Check for exclusions
	// get shader type
	if (!shape->HasShaderProperty()) {
		spdlog::trace(L"Rejecting shape {}: No shader property", shape_block_id);
		return result;
	}

	// only allow BSLightingShaderProperty blocks
	string shape_block_name = shape->GetBlockName();
	if (shape_block_name != "NiTriShape" && shape_block_name != "BSTriShape") {
		spdlog::trace(L"Rejecting shape {}: Incorrect shape block type", shape_block_id);
		return result;
	}

	// get shader from shape
	NiShader* shader = nif.GetShader(shape);
	if (shader == nullptr) {
		// skip if no shader
		spdlog::trace(L"Rejecting shape {}: No shader", shape_block_id);
		return result;
	}

	// check that shader has a texture set
	if (!shader->HasTextureSet()) {
		spdlog::trace(L"Rejecting shape {}: No texture set", shape_block_id);
		return result;
	}

	// check that shader is a BSLightingShaderProperty
	string shader_block_name = shader->GetBlockName();
	if (shader_block_name != "BSLightingShaderProperty") {
		spdlog::trace(L"Rejecting shape {}: Incorrect shader block type", shape_block_id);
		return result;
	}

	auto search_prefixes = getSearchPrefixes(nif, shape);

	// TRUEPBR CONFIG
	bool enable_truepbr = false;
	string matched_path;
	nlohmann::json truepbr_data;
	ParallaxGenTask::updatePGResult(result, shouldApplyTruePBRConfig(nif_file, nif, shape_block_id, shape, shader, search_prefixes, enable_truepbr, truepbr_data, matched_path), ParallaxGenTask::PGResult::SUCCESS_WITH_WARNINGS);
	if (enable_truepbr) {
		// Enable TruePBR on shape
		ParallaxGenTask::updatePGResult(result, applyTruePBRConfigOnShape(nif, shape, shader, truepbr_data, matched_path, nif_modified));
		return result;
	}

	// COMPLEX MATERIAL
	bool enable_cm = false;
	matched_path = "";
	ParallaxGenTask::updatePGResult(result, shouldEnableComplexMaterial(nif_file, nif, shape_block_id, shape, shader, search_prefixes, enable_cm, matched_path), ParallaxGenTask::PGResult::SUCCESS_WITH_WARNINGS);
	if (enable_cm) {
		// Determine if dynamic cubemaps should be set
		bool dynCubemaps = !pgd->checkIfAnyComponentIs(nif_file, dynCubemap_ignore_list) && !pgd->checkIfAnyComponentIs(matched_path, dynCubemap_ignore_list);

		// Enable complex material on shape
		ParallaxGenTask::updatePGResult(result, enableComplexMaterialOnShape(nif, shape, shader, matched_path, dynCubemaps, nif_modified));
		return result;
	}

	// VANILLA PARALLAX
	bool enable_parallax = false;
	matched_path = "";
	ParallaxGenTask::updatePGResult(result, shouldEnableParallax(nif_file, nif, shape_block_id, shape, shader, search_prefixes, has_attached_havok, enable_parallax, matched_path), ParallaxGenTask::PGResult::SUCCESS_WITH_WARNINGS);
	if (enable_parallax) {
		// Enable parallax on shape
		ParallaxGenTask::updatePGResult(result, enableParallaxOnShape(nif, shape, shader, matched_path, nif_modified));
		return result;
	}

	return result;
}

ParallaxGenTask::PGResult ParallaxGen::shouldApplyTruePBRConfig(
	const filesystem::path& nif_file,
	NifFile& nif,
	const uint32_t shape_block_id,
	NiShape* shape,
	NiShader* shader,
	const array<string, 9>& search_prefixes,
	bool& enable_result,
	nlohmann::json& truepbr_data,
	string& matched_path
) const
{
	auto result = ParallaxGenTask::PGResult::SUCCESS;

	if (ignore_truepbr) {
		enable_result = false;
		return result;
	}

	for (auto& truepbr_cfg : pgd->getTruePBRConfigs()) {
		// "nif-filter" attribute
		if (truepbr_cfg.contains("nif-filter") && boost::icontains(nif_file.wstring(), truepbr_cfg["nif-filter"].get<string>())) {
			spdlog::trace(L"Rejecting shape {}: NIF filter", shape_block_id);
			enable_result |= false;
			continue;
		}

		// "path-contains" attribute
		bool contains_match = truepbr_cfg.contains("path_contains") && boost::icontains(convertToWstring(search_prefixes[0]), truepbr_cfg["path_contains"].get<string>());

		bool name_match = false;
		if (truepbr_cfg.contains("match_normal") && boost::iends_with(convertToWstring(search_prefixes[1]), truepbr_cfg["match_normal"].get<string>())) {
			name_match = true;
			matched_path = search_prefixes[1];
		}
		if (truepbr_cfg.contains("match_diffuse") && boost::iends_with(convertToWstring(search_prefixes[0]), truepbr_cfg["match_diffuse"].get<string>())) {
			name_match = true;
			matched_path = search_prefixes[0];
		}

		if (!contains_match && !name_match) {
			spdlog::trace(L"Rejecting shape {}: No matches", shape_block_id);
			enable_result |= false;
			continue;
		}

		enable_result = true;
		truepbr_data.merge_patch(truepbr_cfg);
	}

	return result;
}

ParallaxGenTask::PGResult ParallaxGen::shouldEnableComplexMaterial(
	const filesystem::path& nif_file,
	NifFile& nif,
	const uint32_t shape_block_id,
	NiShape* shape,
	NiShader* shader,
	const array<string, 9>& search_prefixes,
	bool& enable_result,
	string& matched_path
) const
{
	auto result = ParallaxGenTask::PGResult::SUCCESS;
	enable_result = true;  // Start with default true

	if (ignore_complex_material) {
		enable_result = false;
		return result;
	}

	// Check if complex material file exists
	filesystem::path cm_map;
	for (int slot : cm_slot_search) {
		cm_map = search_prefixes[slot] + ParallaxGen::default_suffixes[5][0];
		if (pgd->isComplexMaterialMap(cm_map)) {
			// found complex material map
			matched_path = search_prefixes[slot];
			break;
		}
	}

	if (matched_path.empty()) {
		// no complex material map
		enable_result = false;
		return result;
	}

	// Get shader type
	BSLSP shader_type = static_cast<BSLSP>(shader->GetShaderType());
	if (shader_type != BSLSP::BSLSP_DEFAULT && shader_type != BSLSP::BSLSP_ENVMAP && shader_type != BSLSP::BSLSP_PARALLAX) {
		spdlog::trace(L"Rejecting shape {}: Incorrect shader type", shape_block_id);
		enable_result = false;
		return result;
	}

	// verify that maps match each other
	string diffuse_map;
	uint32_t diffuse_result = nif.GetTextureSlot(shape, diffuse_map, 0);
	if (!diffuse_map.empty() && !pgd->isFile(diffuse_map)) {
		// no diffuse map
		spdlog::trace(L"Rejecting shape {}: Diffuse map missing: {}", shape_block_id, convertToWstring(diffuse_map));
		enable_result = false;
		return result;
	}

	bool same_aspect = false;
	ParallaxGenTask::updatePGResult(result, pgd3d->checkIfAspectRatioMatches(diffuse_map, cm_map, same_aspect), ParallaxGenTask::PGResult::SUCCESS_WITH_WARNINGS);
	if (!same_aspect) {
		spdlog::trace(L"Rejecting shape {} in NIF file {}: Complex material map does not match diffuse map", shape_block_id, nif_file.wstring());
		enable_result = false;
		return result;
	}

	return result;
}

ParallaxGenTask::PGResult ParallaxGen::shouldEnableParallax(
	const filesystem::path& nif_file,
	NifFile& nif,
	const uint32_t shape_block_id,
	NiShape* shape,
	NiShader* shader,
	const array<string, 9>& search_prefixes,
	const bool has_attached_havok,
	bool& enable_result,
	string& matched_path
) const
{
	auto result = ParallaxGenTask::PGResult::SUCCESS;
	enable_result = true;  // Start with default true

	if (ignore_parallax) {
		enable_result = false;
		return result;
	}

	// Check if complex material file exists
	filesystem::path height_map;
	for (int slot : parallax_slot_search) {
		height_map = search_prefixes[slot] + ParallaxGen::default_suffixes[3][0];
		if (pgd->isHeightMap(height_map)) {
			// found complex material map
			matched_path = search_prefixes[slot];
			break;
		}
	}

	if (matched_path.empty()) {
		// no complex material map
		enable_result = false;
		return result;
	}

	// Check if nif has attached havok (results in crashes for vanilla parallax)
	if (has_attached_havok) {
		spdlog::trace(L"Rejecting NIF file {} due to attached havok animations", nif_file.wstring());
		enable_result = false;
		return result;
	}

	// ignore skinned meshes, these don't support parallax
	if (shape->HasSkinInstance() || shape->IsSkinned()) {
		spdlog::trace(L"Rejecting shape {}: Skinned mesh", shape_block_id, nif_file.wstring());
		enable_result = false;
		return result;
	}

	// Enable regular parallax for this shape!
	BSLSP shader_type = static_cast<BSLSP>(shader->GetShaderType());
	if (shader_type != BSLSP::BSLSP_DEFAULT && shader_type != BSLSP::BSLSP_PARALLAX) {
		// don't overwrite existing shaders
		spdlog::trace(L"Rejecting shape {} in NIF file {}: Incorrect shader type", shape_block_id, nif_file.wstring());
		enable_result = false;
		return result;
	}

	// decals don't work with regular parallax
	BSLightingShaderProperty* cur_bslsp = dynamic_cast<BSLightingShaderProperty*>(shader);
	if (cur_bslsp->shaderFlags1 & SSPF1::SLSF1_DECAL || cur_bslsp->shaderFlags1 & SSPF1::SLSF1_DYNAMIC_DECAL) {
		spdlog::trace(L"Rejecting shape {} in NIF file {}: Decal shape", shape_block_id, nif_file.wstring());
		enable_result = false;
		return result;
	}

	// Mesh lighting doesn't work with regular parallax
	if (cur_bslsp->shaderFlags2 & SSPF2::SLSF2_SOFT_LIGHTING || cur_bslsp->shaderFlags2 & SSPF2::SLSF2_RIM_LIGHTING || cur_bslsp->shaderFlags2 & SSPF2::SLSF2_BACK_LIGHTING) {
		spdlog::trace(L"Rejecting shape {} in NIF file {}: Lighting on shape", shape_block_id, nif_file.wstring());
		enable_result = false;
		return result;
	}

	// verify that maps match each other (this is somewhat expense so it happens last)
	string diffuse_map;
	uint32_t diffuse_result = nif.GetTextureSlot(shape, diffuse_map, 0);
	if (!diffuse_map.empty() && !pgd->isFile(diffuse_map)) {
		// no diffuse map
		spdlog::trace(L"Rejecting shape {}: Diffuse map missing: {}", shape_block_id, convertToWstring(diffuse_map));
		enable_result = false;
		return result;
	}

	bool same_aspect = false;
	ParallaxGenTask::updatePGResult(result, pgd3d->checkIfAspectRatioMatches(diffuse_map, height_map, same_aspect), ParallaxGenTask::PGResult::SUCCESS_WITH_WARNINGS);
	if (!same_aspect) {
		spdlog::trace(L"Rejecting shape {} in NIF file {}: Height map does not match diffuse map", shape_block_id, nif_file.wstring());
		enable_result = false;
		return result;
	}

	// All checks passed
	return result;
}

ParallaxGenTask::PGResult ParallaxGen::applyTruePBRConfigOnShape(
	NifFile& nif,
	NiShape* shape,
	NiShader* shader,
	nlohmann::json& truepbr_data,
	const std::string& matched_path,
	bool& nif_modified
) const
{
	// enable TruePBR on shape
	auto result = ParallaxGenTask::PGResult::SUCCESS;

	// Prep
	const auto shader_BSLSP = dynamic_cast<BSLightingShaderProperty*>(shader);

	// "delete" attribute
	if (truepbr_data.contains("delete") && truepbr_data["delete"]) {
		nif.DeleteShape(shape);
		nif_modified = true;
		return result;
	}

	// "smooth_angle" attribute
	if (truepbr_data.contains("smooth_angle")) {
		nif.CalcNormalsForShape(shape, true, true, truepbr_data["smooth_angle"]);
		nif.CalcTangentsForShape(shape);
		nif_modified = true;
	}

	// "auto_uv" attribute
	if (truepbr_data.contains("auto_uv")) {
		vector<Triangle> tris;
		shape->GetTriangles(tris);
		shader_BSLSP->uvScale = auto_uv_scale(nif.GetUvsForShape(shape), nif.GetVertsForShape(shape), tris) / truepbr_data["auto_uv"];
		nif_modified = true;
	}

	// "vertex_colors" attribute
	if (truepbr_data.contains("vertex_colors")) {
		shape->SetVertexColors(truepbr_data["vertex_colors"]);
		if (truepbr_data["vertex_colors"]) {
			shader_BSLSP->shaderFlags2 |= SLSF2_VERTEX_COLORS;
		} else {
			shader_BSLSP->shaderFlags2 &= ~SLSF2_VERTEX_COLORS;
		}

		nif_modified = true;
	}

	// "specular_level" attribute
	if (truepbr_data.contains("specular_level")) {
		shader->SetGlossiness(truepbr_data["specular_level"]);
		nif_modified = true;
	}

	// "subsurface_color" attribute
	if (truepbr_data.contains("subsurface_color") && truepbr_data["subsurface_color"].size() > 2) {
		shader->SetSpecularColor(Vector3(truepbr_data["subsurface_color"][0], truepbr_data["subsurface_color"][1], truepbr_data["subsurface_color"][2]));
		nif_modified = true;
	}

	// "roughness_scale" attribute
	if (truepbr_data.contains("roughness_scale")) {
		shader->SetSpecularStrength(truepbr_data["roughness_scale"]);
		nif_modified = true;
	}

	// "subsurface_opacity" attribute
	if (truepbr_data.contains("subsurface_opacity")) {
		shader_BSLSP->softlighting = truepbr_data["subsurface_opacity"];
		nif_modified = true;
	}

	// "displacement_scale" attribute
	if (truepbr_data.contains("displacement_scale")) {
		shader_BSLSP->rimlightPower = truepbr_data["displacement_scale"];
		nif_modified = true;
	}

	// "env_mapping" attribute
	if (truepbr_data.contains("env_mapping") && truepbr_data["env_mapping"]) {
		shader_BSLSP->bslspShaderType = BSLSP_ENVMAP;
		shader_BSLSP->shaderFlags1 |= SLSF1_ENVIRONMENT_MAPPING;
		shader_BSLSP->shaderFlags2 &= ~SLSF2_GLOW_MAP;
		nif_modified = true;
	}

	// "env_map_scale" attribute
	if (truepbr_data.contains("env_map_scale") && shader_BSLSP->bslspShaderType == BSLSP_ENVMAP) {
		shader_BSLSP->environmentMapScale = truepbr_data["env_map_scale"];
		nif_modified = true;
	}

	// "env_map_scale_mult" attribute
	if (truepbr_data.contains("env_map_scale_mult") && shader_BSLSP->bslspShaderType == BSLSP_ENVMAP) {
		shader_BSLSP->environmentMapScale *= truepbr_data["env_map_scale_mult"];
		nif_modified = true;
	}

	// "cubemap" attribute
	if (truepbr_data.contains("cubemap") && shader_BSLSP->bslspShaderType == BSLSP_ENVMAP && !flag(truepbr_data, "lock_cubemap")) {
		string cubemap = truepbr_data["cubemap"];
		nif.SetTextureSlot(shape, cubemap, 4);
		nif_modified = true;
	}

	// "emmissive_scale" attribute
	if (truepbr_data.contains("emissive_scale")) {
		shader->SetEmissiveMultiple(truepbr_data["emissive_scale"]);
		nif_modified = true;
	}

	// "emmissive_color" attribute
	if (truepbr_data.contains("emissive_color") && truepbr_data["emissive_color"].size() > 3) {
		shader->SetEmissiveColor(Color4(truepbr_data["emissive_color"][0], truepbr_data["emissive_color"][1], truepbr_data["emissive_color"][2], truepbr_data["emissive_color"][3]));
		nif_modified = true;
	}

	// "uv_scale" attribute
	if (truepbr_data.contains("uv_scale")) {
		shader_BSLSP->uvScale = Vector2(truepbr_data["uv_scale"], truepbr_data["uv_scale"]);
		nif_modified = true;
	}

	// "pbr" attribute
	if ((!truepbr_data.contains("pbr") || truepbr_data["pbr"]) && !matched_path.empty()) {
		// no pbr, we can return here
		enableTruePBROnShape(nif, shape, shader, truepbr_data, matched_path, nif_modified);
	}

	// "slotX" attributes
	for (int i = 0; i < 8; i++) {
		string slot_name = "slot" + to_string(i + 1);
		if (truepbr_data.contains(slot_name)) {
			string slot_path = truepbr_data[slot_name];
			nif.SetTextureSlot(shape, slot_path, i);
			nif_modified = true;
		}
	}

	return result;
}

ParallaxGenTask::PGResult ParallaxGen::enableTruePBROnShape(
	NifFile& nif,
	NiShape* shape,
	NiShader* shader,
	nlohmann::json& truepbr_data,
	const string& matched_path,
	bool& nif_modified
) const
{
	// enable TruePBR on shape
	auto result = ParallaxGenTask::PGResult::SUCCESS;

	// Prep
	const auto shader_BSLSP = dynamic_cast<BSLightingShaderProperty*>(shader);

	nif_modified = true;
	string tex_path = string(matched_path);
	if (!boost::istarts_with(tex_path, "textures\\pbr\\")) {
		boost::replace_first(tex_path, "textures\\", "textures\\pbr\\");
	}

	// Get PBR path, which is the path without the matched field
	string matched_field = truepbr_data.contains("match_normal") ? truepbr_data["match_normal"] : truepbr_data["match_diffuse"];
	tex_path.erase(tex_path.length() - matched_field.length(), matched_field.length());

	// "rename" attribute
	string named_field = matched_field;
	if (truepbr_data.contains("rename")) {
		named_field = truepbr_data["rename"];
	}

	// "lock_diffuse" attribute
	auto diffuse = flag(truepbr_data, "lock_diffuse") ? tex_path + matched_field + ParallaxGen::default_suffixes[0][0] : tex_path + named_field + ParallaxGen::default_suffixes[0][0];
	nif.SetTextureSlot(shape, diffuse, 0);

	// "lock_normal" attribute
	auto normal = flag(truepbr_data, "lock_normal") ? tex_path + matched_field + ParallaxGen::default_suffixes[1][0] : tex_path + named_field + ParallaxGen::default_suffixes[1][0];
	nif.SetTextureSlot(shape, normal, 1);

	// "emmisive" attribute
	if (truepbr_data.contains("emissive") && !flag(truepbr_data, "lock_emissive"))
	{
		if (truepbr_data["emissive"]) {
			auto glow = tex_path + named_field + ParallaxGen::default_suffixes[2][0];
			nif.SetTextureSlot(shape, glow, 2);
			shader_BSLSP->shaderFlags1 |= SLSF1_EXTERNAL_EMITTANCE;
		}
		else {
			nif.SetTextureSlot(shape, empty_path, 2);
			shader_BSLSP->shaderFlags1 &= ~SLSF1_EXTERNAL_EMITTANCE;
		}
	}

	// "parallax" attribute
	if (truepbr_data.contains("parallax") && !flag(truepbr_data, "lock_parallax")) {
		if (truepbr_data["parallax"]) {
			auto parallax = tex_path + named_field + ParallaxGen::default_suffixes[3][0];
			nif.SetTextureSlot(shape, parallax, 3);
		}
		else {
			nif.SetTextureSlot(shape, empty_path, 3);
		}
	}

	nif.SetTextureSlot(shape, empty_path, 4);  // unused

	// "lock_rmaos" attribute
	if (!flag(truepbr_data, "lock_rmaos")) {
		auto rmaos = tex_path + named_field + "_rmaos.dds";
		nif.SetTextureSlot(shape, rmaos, 5);
	}

	// "lock_cnr" attribute
	if (!flag(truepbr_data, "lock_cnr")) {
		// "coat_normal" attribute
		if (truepbr_data.contains("coat_normal") && truepbr_data["coat_normal"]) {
			auto cnr = tex_path + named_field + "_cnr.dds";
			nif.SetTextureSlot(shape, cnr, 6);
		}
		else {
			nif.SetTextureSlot(shape, empty_path, 6);
		}
	}

	// "lock_subsurface" attribute
	if (!flag(truepbr_data, "lock_subsurface")) {
		// "subsurface_foliage" attribute
		if ((truepbr_data.contains("subsurface_foliage") && truepbr_data["subsurface_foliage"]) ||
			(truepbr_data.contains("subsurface") && truepbr_data["subsurface"]) ||
			(truepbr_data.contains("coat_diffuse") && truepbr_data["coat_diffuse"])) {
			auto subsurface = tex_path + named_field + ParallaxGen::default_suffixes[7][0];
			nif.SetTextureSlot(shape, subsurface, 7);
		}
		else {
			nif.SetTextureSlot(shape, empty_path, 7);
		}
	}

	// revert to default shader type, remove flags used in other types
	shader_BSLSP->bslspShaderType = BSLSP_DEFAULT;
	shader_BSLSP->shaderFlags1 &= ~SLSF1_ENVIRONMENT_MAPPING;
	shader_BSLSP->shaderFlags1 &= ~SLSF1_PARALLAX;
	shader_BSLSP->shaderFlags2 &= ~SLSF2_GLOW_MAP;
	shader_BSLSP->shaderFlags2 &= ~SLSF2_BACK_LIGHTING;
	shader_BSLSP->shaderFlags2 &= ~SLSF2_MULTI_LAYER_PARALLAX;

	// Enable PBR flag
	shader_BSLSP->shaderFlags2 |= SLSF2_UNUSED01;

	if (truepbr_data.contains("subsurface_foliage") && truepbr_data["subsurface_foliage"] && truepbr_data.contains("subsurface") && truepbr_data["subsurface"]) {
		spdlog::error("Error: Subsurface and foliage shader chosen at once, undefined behavior!");
	}

	// "subsurface_foliage" attribute
	if (truepbr_data.contains("subsurface_foliage")) {
		if (truepbr_data["subsurface_foliage"]) {
			shader_BSLSP->shaderFlags2 |= SLSF2_SOFT_LIGHTING;
		}
		else {
			shader_BSLSP->shaderFlags2 &= ~SLSF2_SOFT_LIGHTING;
		}
	}

	// "subsurface" attribute
	if (truepbr_data.contains("subsurface")) {
		if (truepbr_data["subsurface"]) {
			shader_BSLSP->shaderFlags2 |= SLSF2_RIM_LIGHTING;
		}
		else {
			shader_BSLSP->shaderFlags2 &= ~SLSF2_RIM_LIGHTING;
		}
	}

	// "multilayer" attribute
	if (truepbr_data.contains("multilayer") && truepbr_data["multilayer"]) {
		shader_BSLSP->bslspShaderType = BSLSP_MULTILAYERPARALLAX;
		shader_BSLSP->shaderFlags2 |= SLSF2_MULTI_LAYER_PARALLAX;

		// "coat_color" attribute
		if (truepbr_data.contains("coat_color") && truepbr_data["coat_color"].size() > 2) {
			shader->SetSpecularColor(Vector3(truepbr_data["coat_color"][0], truepbr_data["coat_color"][1], truepbr_data["coat_color"][2]));
		}

		// "coat_specular_level" attribute
		if (truepbr_data.contains("coat_specular_level")) {
			shader_BSLSP->parallaxRefractionScale = truepbr_data["coat_specular_level"];
		}

		// "coat_roughness" attribute
		if (truepbr_data.contains("coat_roughness")) {
			shader_BSLSP->parallaxInnerLayerThickness = truepbr_data["coat_roughness"];
		}

		// "coat_strength" attribute
		if (truepbr_data.contains("coat_strength")) {
			shader_BSLSP->softlighting = truepbr_data["coat_strength"];
		}

		// "coat_diffuse" attribute
		if (truepbr_data.contains("coat_diffuse")) {
			if (truepbr_data["coat_diffuse"]) {
				shader_BSLSP->shaderFlags2 |= SLSF2_EFFECT_LIGHTING;
			}
			else {
				shader_BSLSP->shaderFlags2 &= ~SLSF2_EFFECT_LIGHTING;
			}
		}

		// "coat_parallax" attribute
		if (truepbr_data.contains("coat_parallax")) {
			if (truepbr_data["coat_parallax"]) {
				shader_BSLSP->shaderFlags2 |= SLSF2_SOFT_LIGHTING;
			}
			else {
				shader_BSLSP->shaderFlags2 &= ~SLSF2_SOFT_LIGHTING;
			}
		}

		// "coat_normal" attribute
		if (truepbr_data.contains("coat_normal")) {
			if (truepbr_data["coat_normal"]) {
				shader_BSLSP->shaderFlags2 |= SLSF2_BACK_LIGHTING;
			}
			else {
				shader_BSLSP->shaderFlags2 &= ~SLSF2_BACK_LIGHTING;
			}
		}

		// "inner_uv_scale" attribute
		if (truepbr_data.contains("inner_uv_scale")) {
			shader_BSLSP->parallaxInnerLayerTextureScale = Vector2(truepbr_data["inner_uv_scale"], truepbr_data["inner_uv_scale"]);
		}
	}

	return result;
}

ParallaxGenTask::PGResult ParallaxGen::enableComplexMaterialOnShape(
	NifFile& nif,
	NiShape* shape,
	NiShader* shader,
	const string& matched_path,
	bool dynCubemaps,
	bool& nif_modified
) const
{
	// enable complex material on shape
	auto result = ParallaxGenTask::PGResult::SUCCESS;

	// 1. set shader type to env map
	if (shader->GetShaderType() != BSLSP::BSLSP_ENVMAP) {
		shader->SetShaderType(BSLSP::BSLSP_ENVMAP);
		nif_modified = true;
	}
	// 2. set shader flags
	BSLightingShaderProperty* cur_bslsp = dynamic_cast<BSLightingShaderProperty*>(shader);
	if(cur_bslsp->shaderFlags1 & SSPF1::SLSF1_PARALLAX) {
		// Complex material cannot have parallax shader flag
		cur_bslsp->shaderFlags1 &= ~SSPF1::SLSF1_PARALLAX;
	}

	if (!(cur_bslsp->shaderFlags1 & SSPF1::SLSF1_ENVIRONMENT_MAPPING)) {
		cur_bslsp->shaderFlags1 |= SSPF1::SLSF1_ENVIRONMENT_MAPPING;
		nif_modified = true;
	}

	// 5. set complex material texture
	string height_map;
	uint32_t height_result = nif.GetTextureSlot(shape, height_map, 3);
	if (height_result != 0 || !height_map.empty()) {
		// remove height map
		string new_height_map = "";
		nif.SetTextureSlot(shape, new_height_map, 3);
		nif_modified = true;
	}

	string env_map;
	uint32_t env_result = nif.GetTextureSlot(shape, env_map, 5);
	string new_env_map = matched_path + ParallaxGen::default_suffixes[5][0];
	if (!boost::iequals(env_map, new_env_map)) {
		// add height map
		nif.SetTextureSlot(shape, new_env_map, 5);
		nif_modified = true;
	}

	// Dynamic cubemaps (if enabled)
	if (dynCubemaps) {
		// add cubemap to slot
		string cubemap;
		uint32_t cubemap_result = nif.GetTextureSlot(shape, cubemap, 4);
		string new_cubemap = ParallaxGenDirectory::default_cubemap_path.string();

		if (!boost::iequals(cubemap, new_cubemap)) {
			// only fill if dyn cubemap not already there
			nif.SetTextureSlot(shape, new_cubemap, 4);
			nif_modified = true;
		}
	}

	return result;
}

ParallaxGenTask::PGResult ParallaxGen::enableParallaxOnShape(
	NifFile& nif,
	NiShape* shape,
	NiShader* shader,
	const string& matched_path,
	bool& nif_modified
) const
{
	// enable parallax on shape
	auto result = ParallaxGenTask::PGResult::SUCCESS;

	// 1. set shader type to parallax
	if (shader->GetShaderType() != BSLSP::BSLSP_PARALLAX) {
		shader->SetShaderType(BSLSP::BSLSP_PARALLAX);
		nif_modified = true;
	}
	// 2. Set shader flags
	BSLightingShaderProperty* cur_bslsp = dynamic_cast<BSLightingShaderProperty*>(shader);
	if(cur_bslsp->shaderFlags1 & SSPF1::SLSF1_ENVIRONMENT_MAPPING) {
		// Vanilla parallax cannot have environment mapping flag
		cur_bslsp->shaderFlags1 &= ~SSPF1::SLSF1_ENVIRONMENT_MAPPING;
	}

	if (!(cur_bslsp->shaderFlags1 & SSPF1::SLSF1_PARALLAX)) {
		cur_bslsp->shaderFlags1 |= SSPF1::SLSF1_PARALLAX;
		nif_modified = true;
	}
	// 3. set vertex colors for shape
	if (!shape->HasVertexColors()) {
		shape->SetVertexColors(true);
		nif_modified = true;
	}
	// 4. set vertex colors for shader
	if (!shader->HasVertexColors()) {
		shader->SetVertexColors(true);
		nif_modified = true;
	}
	// 5. set parallax heightmap texture
	string height_map;
	uint32_t height_result = nif.GetTextureSlot(shape, height_map, 3);
	string new_height_map = matched_path + ParallaxGen::default_suffixes[3][0];

	if (!boost::iequals(height_map, new_height_map)) {
		// add height map
		nif.SetTextureSlot(shape, new_height_map, 3);
		nif_modified = true;
	}

	return result;
}

const array<string, 9> ParallaxGen::getSearchPrefixes(
	NifFile& nif,
	nifly::NiShape* shape
)
{
	array<string, 9> out_prefixes;

	// Loop through each texture slot
	for (uint32_t i = 0; i < 9; i++) {
		string texture;
		uint32_t result = nif.GetTextureSlot(shape, texture, i);

		if (result == 0 || texture.empty()) {
			// no texture in slot
			continue;
		}

		// Get default suffixes
		auto i_endings = ParallaxGen::default_suffixes[i];
		// loop through suffixes
		for (string suffix : i_endings) {
			if (boost::iends_with(texture, suffix)) {
				string search_prefix = replaceLastOf(texture, suffix, "");
				out_prefixes[i] = search_prefix;
				break;
			}
		}
	}

	return out_prefixes;
}

void ParallaxGen::addFileToZip(
	mz_zip_archive& zip,
	const filesystem::path& filePath,
	const filesystem::path& zipPath
) const
{
	// ignore zip file itself
	if (filePath == zipPath) {
		return;
	}

	// open file stream
	vector<std::byte> buffer = getFileBytes(filePath);

	// get relative path
	filesystem::path zip_relative_path = filePath.lexically_relative(output_dir);

	string zip_file_path = wstring_to_utf8(zip_relative_path.wstring());

	// add file to zip
    if (!mz_zip_writer_add_mem(&zip, zip_file_path.c_str(), buffer.data(), buffer.size(), MZ_NO_COMPRESSION)) {
		spdlog::error(L"Error adding file to zip: {}", filePath.wstring());
		exitWithUserInput(1);
    }
}

void ParallaxGen::zipDirectory(
	const filesystem::path& dirPath,
	const filesystem::path& zipPath
) const
{
	mz_zip_archive zip;

	// init to 0
    memset(&zip, 0, sizeof(zip));

	// check if directory exists
	if (!filesystem::exists(dirPath)) {
		spdlog::info("No outputs were created");
		exitWithUserInput(0);
	}

	// Check if file already exists and delete
	if (filesystem::exists(zipPath)) {
		spdlog::info(L"Deleting existing output zip file: {}", zipPath.wstring());
		filesystem::remove(zipPath);
	}

	// initialize file
	string zip_path_string = wstring_to_utf8(zipPath);
    if (!mz_zip_writer_init_file(&zip, zip_path_string.c_str(), 0)) {
		spdlog::critical(L"Error creating zip file: {}", zipPath.wstring());
		exitWithUserInput(1);
    }

	// add each file in directory to zip
    for (const auto &entry : filesystem::recursive_directory_iterator(dirPath)) {
        if (filesystem::is_regular_file(entry.path())) {
            addFileToZip(zip, entry.path(), zipPath);
        }
    }

	// finalize zip
    if (!mz_zip_writer_finalize_archive(&zip)) {
		spdlog::critical(L"Error finalizing zip archive: {}", zipPath.wstring());
		exitWithUserInput(1);
    }

    mz_zip_writer_end(&zip);

	spdlog::info(L"Please import this file into your mod manager: {}", zipPath.wstring());
}

//
// Helpers
//

Vector2 ParallaxGen::abs2(Vector2 v) {
	return Vector2(abs(v.u), abs(v.v));
}

Vector2 ParallaxGen::auto_uv_scale(const vector<Vector2>* uvs, const vector<Vector3>* verts, vector<Triangle>& tris) {
	Vector2 scale;
	for (const Triangle& t : tris) {
		auto v1 = (*verts)[t.p1];
		auto v2 = (*verts)[t.p2];
		auto v3 = (*verts)[t.p3];
		auto uv1 = (*uvs)[t.p1];
		auto uv2 = (*uvs)[t.p2];
		auto uv3 = (*uvs)[t.p3];

		//auto cross = (v2 - v1).cross(v3 - v1);
		//auto uv_cross = Vector3((uv2 - uv1).u, (uv2 - uv1).v, 0).cross(Vector3((uv3 - uv1).u, (uv3 - uv1).v, 0));
		//auto s = cross.length() / uv_cross.length();
		//scale += Vector2(s, s);
		//auto s = (abs(uv2 - uv1) / (v2 - v1).length() + abs(uv3 - uv1) / (v3 - v1).length() + abs(uv2 - uv3) / (v2 - v3).length())/3;
		//scale += Vector2(1.0 / s.u, 1.0 / s.v);
		auto s = (abs2(uv2 - uv1) + abs2(uv3 - uv1)) / ((v2 - v1).length() + (v3 - v1).length());
		scale += Vector2(1.0f / s.u, 1.0f / s.v);
	}

	scale *= 10.0 / 4.0;
	scale /= static_cast<float>(tris.size());
	scale.u = min(scale.u, scale.v);
	scale.v = min(scale.u, scale.v);

	return scale;
}

bool ParallaxGen::flag(nlohmann::json& json, const char* key) {
	return json.contains(key) && json[key];
}