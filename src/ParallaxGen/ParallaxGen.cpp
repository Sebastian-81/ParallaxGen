#include "ParallaxGen/ParallaxGen.hpp"

#include <spdlog/spdlog.h>
#include <boost/iostreams/device/array.hpp>
#include <boost/iostreams/stream.hpp>
#include <boost/algorithm/string.hpp>
#include <vector>
#include <fstream>

#include "ParallaxGenUtil/ParallaxGenUtil.hpp"

using namespace std;
namespace fs = filesystem;
using namespace nifly;

ParallaxGen::ParallaxGen(const fs::path output_dir, ParallaxGenDirectory* pgd, ParallaxGenD3D* pgd3d)
{
    // constructor
    this->output_dir = output_dir;
    this->pgd = pgd;
	this->pgd3d = pgd3d;
}

void ParallaxGen::patchMeshes(vector<fs::path>& meshes, vector<fs::path>& heightMaps, vector<fs::path>& complexMaterialMaps)
{
	// patch meshes
	// loop through each mesh nif file
	size_t finished_task = 0;
	size_t num_meshes = meshes.size();
	for (fs::path mesh : meshes) {
		if (finished_task % 100 == 0) {
			double progress = (double)finished_task / num_meshes * 100.0;
			spdlog::info("NIFs Processed: {}/{} ({:.1f}%)", finished_task, num_meshes, progress);
		}

		processNIF(mesh, heightMaps, complexMaterialMaps);
		finished_task++;
	}

	// create state file
	ofstream state_file(output_dir / parallax_state_file);
	state_file.close();
}

void ParallaxGen::zipMeshes() {
	// zip meshes
	spdlog::info("Zipping meshes...");
	zipDirectory(output_dir, output_dir / "ParallaxGen_Output.zip");
}

void ParallaxGen::deleteMeshes() {
	// delete meshes
	spdlog::info("Cleaning up meshes generated by ParallaxGen...");
	// Iterate through the folder
	for (const auto& entry : fs::directory_iterator(output_dir)) {
		if (fs::is_directory(entry.path())) {
			// Remove the directory and all its contents
			try {
				fs::remove_all(entry.path());
				spdlog::trace(L"Deleted directory {}", entry.path().wstring());
			}
			catch (const exception& e) {
				spdlog::error(L"Error deleting directory {}: {}", entry.path().wstring(), ParallaxGenUtil::convertToWstring(e.what()));
			}
		}

		// remove state file
		if (entry.path().filename().wstring() == L"PARALLAXGEN_DONTDELETE") {
			try {
				fs::remove(entry.path());
			}
			catch (const exception& e) {
				spdlog::error(L"Error deleting state file {}: {}", entry.path().wstring(), ParallaxGenUtil::convertToWstring(e.what()));
			}
		}
	}
}

void ParallaxGen::deleteOutputDir() {
	// delete output directory
	if (fs::exists(output_dir)) {
		spdlog::info("Deleting existing ParallaxGen output...");

		try {
			fs::remove_all(output_dir);
		}
		catch (const exception& e) {
			spdlog::critical(L"Error deleting output directory {}: {}", output_dir.wstring(), ParallaxGenUtil::convertToWstring(e.what()));
			ParallaxGenUtil::exitWithUserInput(1);
		}
	}
}

// shorten some enum names
typedef BSLightingShaderPropertyShaderType BSLSP;
typedef SkyrimShaderPropertyFlags1 SSPF1;
typedef SkyrimShaderPropertyFlags2 SSPF2;
void ParallaxGen::processNIF(const fs::path& nif_file, vector<fs::path>& heightMaps, vector<fs::path>& complexMaterialMaps)
{
	const fs::path output_file = output_dir / nif_file;
	if (fs::exists(output_file)) {
		spdlog::error(L"Unable to process NIF file, file already exists: {}", nif_file.wstring());
		return;
	}

	// process nif file
	vector<std::byte> nif_file_data = pgd->getFile(nif_file);

	if (nif_file_data.empty()) {
		spdlog::warn(L"Unable to read NIF file (ignoring): {}", nif_file.wstring());
		return;
	}

	boost::iostreams::array_source nif_array_source(reinterpret_cast<const char*>(nif_file_data.data()), nif_file_data.size());
	boost::iostreams::stream<boost::iostreams::array_source> nif_stream(nif_array_source);

	// load nif file
	NifFile nif;

	try {
		// try block for loading nif
		nif.Load(nif_stream);
	}
	catch (const exception& e) {
		spdlog::warn(L"Error reading NIF file (ignoring): {}, {}", nif_file.wstring(), ParallaxGenUtil::convertToWstring(e.what()));
		return;
	}

	if (!nif.IsValid()) {
		spdlog::warn(L"Invalid NIF file (ignoring): {}", nif_file.wstring());
		return;
	}

	bool nif_modified = false;

	// ignore nif if has attached havok animations
	vector<NiObject*> block_tree;
	nif.GetTree(block_tree);

	// loop through blocks
	for (NiObject* block : block_tree) {
		if (block->GetBlockName() == "BSBehaviorGraphExtraData") {
			spdlog::trace(L"Rejecting NIF file {} due to attached havok animations", nif_file.wstring());
			return;
		}
	}

	// loop through each node in nif
	for (NiShape* shape : nif.GetShapes()) {
		const auto block_id = nif.GetBlockID(shape);

		// exclusions
		// get shader type
		if (!shape->HasShaderProperty()) {
			spdlog::trace(L"Rejecting shape {} in NIF file {}: No shader property", block_id, nif_file.wstring());
			continue;
		}

		// only allow BSLightingShaderProperty blocks
		string shape_block_name = shape->GetBlockName();
		if (shape_block_name != "NiTriShape" && shape_block_name != "BSTriShape") {
			spdlog::trace(L"Rejecting shape {} in NIF file {}: Incorrect shape block type", block_id, nif_file.wstring());
			continue;
		}

		// ignore skinned meshes, these don't support parallax
		if (shape->HasSkinInstance() || shape->IsSkinned()) {
			spdlog::trace(L"Rejecting shape {} in NIF file {}: Skinned mesh", block_id, nif_file.wstring());
			continue;
		}

		// get shader from shape
		NiShader* shader = nif.GetShader(shape);
		if (shader == nullptr) {
			// skip if no shader
			spdlog::trace(L"Rejecting shape {} in NIF file {}: No shader", block_id, nif_file.wstring());
			continue;
		}

		// check that shader has a texture set
		if (!shader->HasTextureSet()) {
			spdlog::trace(L"Rejecting shape {} in NIF file {}: No texture set", block_id, nif_file.wstring());
			continue;
		}

		string shader_block_name = shader->GetBlockName();
		if (shader_block_name != "BSLightingShaderProperty") {
			spdlog::trace(L"Rejecting shape {} in NIF file {}: Incorrect shader block type", block_id, nif_file.wstring());
			continue;
		}

		// don't enable parallax on decals because that gets rid of blending
		BSLightingShaderProperty* cur_bslsp = dynamic_cast<BSLightingShaderProperty*>(shader);
		if (cur_bslsp->shaderFlags1 & SSPF1::SLSF1_DECAL || cur_bslsp->shaderFlags1 & SSPF1::SLSF1_DYNAMIC_DECAL) {
			spdlog::trace(L"Rejecting shape {} in NIF file {}: Decal shape", block_id, nif_file.wstring());
			continue;
		}

		if (cur_bslsp->shaderFlags2 & SSPF2::SLSF2_BACK_LIGHTING) {
			spdlog::trace(L"Rejecting shape {} in NIF file {}: Back lighting shape", block_id, nif_file.wstring());
			continue;
		}

		// Ignore if shader type is not 0 (nothing) or 1 (environemnt map) or 3 (parallax)
		BSLSP shader_type = static_cast<BSLSP>(shader->GetShaderType());
		if (shader_type != BSLSP::BSLSP_DEFAULT && shader_type != BSLSP::BSLSP_ENVMAP && shader_type != BSLSP::BSLSP_PARALLAX) {
			spdlog::trace(L"Rejecting shape {} in NIF file {}: Incorrect shader type", block_id, nif_file.wstring());
			continue;
		}

		// build search vector
		vector<string> search_prefixes;
		// diffuse map lookup first
		string diffuse_map;
		uint32_t diffuse_result = nif.GetTextureSlot(shape, diffuse_map, 0);
		if (diffuse_result == 0) {
			continue;
		}
		ParallaxGenUtil::addUniqueElement(search_prefixes, diffuse_map.substr(0, diffuse_map.find_last_of('.')));
		// normal map lookup
		string normal_map;
		uint32_t normal_result = nif.GetTextureSlot(shape, normal_map, 1);
		if (diffuse_result > 0) {
			ParallaxGenUtil::addUniqueElement(search_prefixes, normal_map.substr(0, normal_map.find_last_of('_')));
		}

		// check if meshes should be changed
		for (string& search_prefix : search_prefixes) {
			// check if complex material file exists
			fs::path search_path;
			string search_prefix_lower = boost::algorithm::to_lower_copy(search_prefix);

			// processing for complex material
            search_path = search_prefix_lower + "_m.dds";
            if (find(complexMaterialMaps.begin(), complexMaterialMaps.end(), search_path) != complexMaterialMaps.end()) {
                // Enable complex parallax for this shape!
                nif_modified |= enableComplexMaterialOnShape(nif, shape, shader, search_prefix);
                break;
            }

			// processing for parallax
            search_path = search_prefix_lower + "_p.dds";
            if (find(heightMaps.begin(), heightMaps.end(), search_path) != heightMaps.end()) {
                // Enable regular parallax for this shape!
				if (shader_type != BSLSP::BSLSP_DEFAULT && shader_type != BSLSP::BSLSP_PARALLAX) {
					// this avoids an env map mesh being reverted to parallax mesh
					spdlog::trace(L"Rejecting shape {} in NIF file {}: Incorrect shader type", block_id, nif_file.wstring());
					continue;
				}

				// verify that maps match each other
				cv::Mat diffuse_map_mat = pgd3d->decodeDDS(pgd->getFile(diffuse_map));
				cv::Mat height_map_mat = pgd3d->decodeDDS(pgd->getFile(search_path));

                nif_modified |= enableParallaxOnShape(nif, shape, shader, search_prefix);
                break;
            }
		}
	}

	// save NIF if it was modified
	if (nif_modified) {
		spdlog::debug(L"NIF Modified: {}", nif_file.wstring());

		// create directories if required
		fs::create_directories(output_file.parent_path());

		if (nif.Save(output_file, nif_save_options)) {
			spdlog::error(L"Unable to save NIF file: {}", nif_file.wstring());
		}
	}
}

bool ParallaxGen::enableComplexMaterialOnShape(NifFile& nif, NiShape* shape, NiShader* shader, const string& search_prefix)
{
	// enable complex material on shape
	bool changed = false;
	// 1. set shader type to env map
	if (shader->GetShaderType() != BSLSP::BSLSP_ENVMAP) {
		shader->SetShaderType(BSLSP::BSLSP_ENVMAP);
		changed = true;
	}
	// 2. set shader flags
	BSLightingShaderProperty* cur_bslsp = dynamic_cast<BSLightingShaderProperty*>(shader);
	if (!(cur_bslsp->shaderFlags1 & SSPF1::SLSF1_ENVIRONMENT_MAPPING)) {
		cur_bslsp->shaderFlags1 |= SSPF1::SLSF1_ENVIRONMENT_MAPPING;
		changed = true;
	}
	// 3. set vertex colors for shape
	if (!shape->HasVertexColors()) {
		shape->SetVertexColors(true);
		changed = true;
	}
	// 4. set vertex colors for shader
	if (!shader->HasVertexColors()) {
		shader->SetVertexColors(true);
		changed = true;
	}
	// 5. set complex material texture
	string env_map;
	uint32_t env_result = nif.GetTextureSlot(shape, env_map, 5);
	if (env_result == 0 || env_map.empty()) {
		// add height map
		string new_env_map = search_prefix + "_m.dds";
		nif.SetTextureSlot(shape, new_env_map, 5);
		changed = true;
	}
	return changed;
}

bool ParallaxGen::enableParallaxOnShape(NifFile& nif, NiShape* shape, NiShader* shader, const string& search_prefix)
{
	// enable parallax on shape
	bool changed = false;
	// 1. set shader type to parallax
	if (shader->GetShaderType() != BSLSP::BSLSP_PARALLAX) {
		shader->SetShaderType(BSLSP::BSLSP_PARALLAX);
		changed = true;
	}
	// 2. Set shader flags
	BSLightingShaderProperty* cur_bslsp = dynamic_cast<BSLightingShaderProperty*>(shader);
	if (!(cur_bslsp->shaderFlags1 & SSPF1::SLSF1_PARALLAX)) {
		cur_bslsp->shaderFlags1 |= SSPF1::SLSF1_PARALLAX;
		changed = true;
	}
	// 3. set vertex colors for shape
	if (!shape->HasVertexColors()) {
		shape->SetVertexColors(true);
		changed = true;
	}
	// 4. set vertex colors for shader
	if (!shader->HasVertexColors()) {
		shader->SetVertexColors(true);
		changed = true;
	}
	// 5. set parallax heightmap texture
	string height_map;
	uint32_t height_result = nif.GetTextureSlot(shape, height_map, 3);
	if (height_result == 0 || height_map.empty()) {
		// add height map
		string new_height_map = search_prefix + "_p.dds";
		nif.SetTextureSlot(shape, new_height_map, 3);
		changed = true;
	}

	return changed;
}

void ParallaxGen::addFileToZip(mz_zip_archive& zip, const fs::path& filePath, const fs::path& zipPath)
{
	// ignore zip file itself
	if (filePath == zipPath) {
		return;
	}

	// open file stream
	vector<std::byte> buffer = ParallaxGenUtil::getFileBytes(filePath);

	// get relative path
	fs::path zip_relative_path = filePath.lexically_relative(output_dir);

	string zip_file_path = ParallaxGenUtil::wstring_to_utf8(zip_relative_path.wstring());

	// add file to zip
    if (!mz_zip_writer_add_mem(&zip, zip_file_path.c_str(), buffer.data(), buffer.size(), MZ_NO_COMPRESSION)) {
		spdlog::error(L"Error adding file to zip: {}", filePath.wstring());
		ParallaxGenUtil::exitWithUserInput(1);
    }
}

void ParallaxGen::zipDirectory(const fs::path& dirPath, const fs::path& zipPath)
{
	mz_zip_archive zip;

	// init to 0
    memset(&zip, 0, sizeof(zip));

	// check if directory exists
	if (!fs::exists(dirPath)) {
		spdlog::info("No outputs were created");
		ParallaxGenUtil::exitWithUserInput(0);
	}

	// initialize file
	string zip_path_string = ParallaxGenUtil::wstring_to_utf8(zipPath);
    if (!mz_zip_writer_init_file(&zip, zip_path_string.c_str(), 0)) {
		spdlog::critical(L"Error creating zip file: {}", zipPath.wstring());
		ParallaxGenUtil::exitWithUserInput(1);
    }

	// add each file in directory to zip
    for (const auto &entry : fs::recursive_directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            addFileToZip(zip, entry.path(), zipPath);
        }
    }

	// finalize zip
    if (!mz_zip_writer_finalize_archive(&zip)) {
		spdlog::critical(L"Error finalizing zip archive: {}", zipPath.wstring());
		ParallaxGenUtil::exitWithUserInput(1);
    }

    mz_zip_writer_end(&zip);

	spdlog::info(L"Please import this file into your mod manager: {}", zipPath.wstring());
}
